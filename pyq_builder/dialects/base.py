import dataclasses
import enum
import importlib
import re
import typing
from typing import AsyncContextManager, Protocol

from pyq_builder.connection import Connection
from pyq_builder.utils.comparison import Comparator, Comparison
from pyq_builder.utils.container import Container


class DialectParser(Protocol):
    def stringify(self) -> str:
        ...


class HasStringify(Protocol):
    def stringify(self) -> str:
        pass


class Resolver(Protocol):
    def or_(self, where: typing.Iterable[HasStringify]):
        pass

    def and_(self, where: typing.Iterable[HasStringify]):
        pass

    def compare(self, field: str, comp: Comparison) -> Comparator:
        pass


class Dialect(Protocol):
    parsers = Container[DialectParser]()
    resolver: Resolver

    @classmethod
    def register(cls, name: str, parser: DialectParser) -> None:
        cls.parsers[name] = parser

    @staticmethod
    def string_wrap(string: str) -> str:
        """Wraps string using expected delimiters. Ex. MySQL -> 'val'"""

    @staticmethod
    def stringify_statement(string: str) -> str:
        """Wraps statement with delimiters to avoid keyword collision"""

    @staticmethod
    def isolate(string) -> str:
        """isolate expression in statement"""

    def __getitem__(self, name: str):
        return self.parsers[name]


class ClauseDialectParser(Protocol):
    ...


class Connector(Protocol):
    def __init__(self, cfg: "QBuilderConfig"):
        pass

    def acquire(self) -> AsyncContextManager[Connection]:
        pass

    async def release(self, client: Connection) -> None:
        pass

    def is_closed(self, client: Connection):
        pass

    async def connect(self) -> Connection:
        pass

    async def create_pool(self):
        pass

    async def close_pool(self):
        pass

    @property
    def is_connected(self) -> bool:
        return False


class Compiler:
    def __init__(self, name: str):
        self._name = name

    def _get_from_mod(
        self,
        suffix: str,
        name: str = None,
        mod_path: str = None,
    ):
        name = name or self._name
        mod = importlib.import_module(
            mod_path or self.__module__.replace(".base", f".{name}")
        )
        return getattr(
            mod,
            "".join(
                (
                    name.title(),
                    suffix.title(),
                )
            ),
        )

    def get_dialect(self, name: str = None, mod_path: str = None) -> Dialect:
        return self._get_from_mod("dialect", name, mod_path)()

    def get_connector(
        self,
        name: str = None,
        mod_path: str = None,
    ) -> typing.Type[Connector]:
        return self._get_from_mod("connector", name, mod_path)


class DriverTypes(Protocol):
    port: int
    has_config: bool
    async_driver: str
    sync_driver: str

    config = {}
    connection_regexp = re.compile(
        r"^(?P<driver>.+?(?=:))://"
        "(((?P<user>.+?(?=:)):(?P<passwd>.+?(?=@))@"
        "(?P<host>.+?(?=[:/]))(:(?P<port>[0-9]+?(?=/)))?(/(?P<name>.+))?)"
        "|(?P<filename>.+))$"
    )

    def get_connection_uri(self, is_async: bool, cfg: "QBuilderConfig") -> str:
        """Returns autogenerated driver uri for sqlalchemy create_engine()"""
        driver_prefix = self.async_driver if is_async else self.sync_driver
        return f"{driver_prefix}://{cfg.user}:{cfg.passwd}@{cfg.host}:{cfg.get_port()}/{cfg.name}"


class MysqlDriver(DriverTypes):
    """Driver Default values for MySQL Connection"""

    port = 3306
    async_driver = "aiomysql"
    sync_driver = "pymysql"
    has_config = False


class PostgresDriver(DriverTypes):
    """Driver Default values for PostgreSQL Connection"""

    port = 5432
    async_driver = "asyncpg"
    sync_driver = "psycopg2"
    has_config = False


class SqliteDriver(DriverTypes):
    port = 0
    async_driver = "aiosqlite"
    sync_driver = "sqlite"
    has_config = True

    def get_connection_uri(self, is_async: bool, cfg: "QBuilderConfig") -> str:
        driver_prefix = self.async_driver if is_async else self.sync_driver
        return "{driver}:///{host}".format(driver=driver_prefix, host=cfg.host)


class Driver(str, enum.Enum):
    MYSQL = "mysql"
    POSTGRES = "postgres"
    SQLITE = "sqlite"


_drivers_mapping = {
    Driver.MYSQL: MysqlDriver(),
    Driver.POSTGRES: PostgresDriver(),
    Driver.SQLITE: SqliteDriver(),
}
_reverse_drivers_mapping: typing.Dict[DriverTypes, Driver] = {
    type(val): key for key, val in _drivers_mapping.items()
}


@dataclasses.dataclass
class QBuilderConfig:
    """Database configuration params
    Obs: pass filename as host if using sqlite"""

    driver: DriverTypes
    host: str
    name: str = ""
    user: str = ""
    passwd: str = ""
    port: int = -1
    _pool_size: int = 20
    _pool_recycle: int = 3600
    _max_overflow: int = 0

    def __post_init__(self):
        if not isinstance(self.driver, Driver):
            return
        self.driver = _drivers_mapping[self.driver]

    def get_port(self):
        return self.port if self.port != -1 else self.driver.port

    def get_uri(self, *, is_async: bool):
        return self.driver.get_connection_uri(is_async, self)

    @property
    def pool_config(self) -> typing.Dict[str, int]:
        if self.driver.has_config:
            return self.driver.config
        return {
            "pool_size": self._pool_size,
            "pool_recycle": self._pool_recycle,
            "max_overflow": self._max_overflow,
        }

    @property
    def pool_recycle(self):
        return self._pool_recycle

    @property
    def pool_size(self):
        return self._pool_size

    @classmethod
    def from_uri(cls, string: str) -> "QBuilderConfig":
        parsed = re.match(DriverTypes.connection_regexp, string)
        if not parsed:
            # TODO: Custom exception
            raise Exception
        matches = parsed.groupdict()
        if filename := matches.pop("filename", None):
            return cls(driver=Driver(matches.pop("driver")), host=filename)
        matches["driver"] = Driver(matches.pop("driver"))
        return cls(**matches)

    def get_compiler(self):
        return Compiler(_reverse_drivers_mapping[self.driver].value)

    def get_connector(self):
        return self.get_compiler().get_connector()(self)
